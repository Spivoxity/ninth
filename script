: # immediate 10 scan pop ;
# Now we can write comments like this

# Stack manipulations
: -rot rot rot ;
: over swap dup rot swap ;
: nip swap pop ;
: tuck dup rot rot ;

# Abbreviations
: 1+ 1 + ;
: 1- 1 - ;
: 2/ 1 asr ;
: cell+ 4 + ;
: cell- 4 - ;
: space 32 putc ;
: aligned 1- tuck + swap invert & ;
: on 1 swap ! ;
: off 0 swap ! ;

: xchg # Exchange between stack and memory
dup @ -rot ! ;

# Access to R-stack
: >r rp @ xchg rp @ cell- dup rp ! ! ;
: r> rp @ @ rp @ cell+ dup rp ! xchg ;

# Quotations
: ' word [create] ;
: ['] immediate ' lit lit gentok gentok ;
: [compile] immediate ' gentok ;
: quote immediate lit lit gentok ' gentok lit gentok gentok ;

# Control structures
: here dp @ ;

: >mark here 0 gentok ;
: >resolve here over - 2/ 1- swap tok! ;

: <mark here ;
: <resolve here - 2/ 1- gentok ;

: if immediate quote branch0 >mark ;
: else immediate quote branch >mark swap >resolve ;
: fi immediate >resolve ;

: do immediate <mark 0 ;
: while immediate pop quote branch0 >mark ;
: od immediate swap quote branch <resolve dup if >resolve else pop fi ;

# Storage allocation
: , here dup cell+ dp ! ! ;
: constant word [create] CONST here defword , ;
: variable word [create] VAR here defword ;
: allot here + dp ! ;

: dump sp @ cell+ do dup SBASE < while dup @ . cell+ od pop ;
: clear SBASE 8 - sp ! ;

# Strings
: char word ch@ ;
: [char] immediate quote lit word ch@ gentok ;
: strlen 0 swap do dup ch@ while swap 1+ swap 1+ od pop ;
: putstr do dup ch@ dup while putc 1+ od pop pop ;
: litstr r> dup 2 + swap tok@ over + >r ;

: " immediate
quote litstr 0 gentok [char] " scan 
strlen 1+ 2 aligned
dup here 2 - tok! here + dp ! ;

: ." immediate [compile] " quote putstr ;

# Dictionary layout
: def>next MEM + tok@ ;
: def>exec MEM + 4 + @ ;
: def>data MEM + 8 + @ ;
: def>name MEM + 12 + ;

: names 
dict @ do dup while dup space def>name putstr def>next od pop ;

# Disassembler
: isword # Test if token is in the dictionary
dict @ 
do dup 0 = if pop pop 0 0 
  else over over = if pop pop 1 0 else 1 fi fi 
while def>next od ;

: dis # Disassemble up to exit token
word find if
  dup def>exec ENTER = if
    def>data 
    do dup tok@
      dup isword if 
        dup space def>name putstr 
        def>exec EXIT = not
      else
        . 1
      fi
    while 2 + od nl
  else
    def>name putstr space ." is not a secondary" nl
  fi
else
  putstr space ." is unknown" nl
fi ;





' fac pop

: fac dup if dup 1- fac * else pop 1 fi ;

10 fac . nl # 3628800

: faciter 1 swap do dup while tuck * swap 1- od pop ;

9 faciter . nl # 362880

