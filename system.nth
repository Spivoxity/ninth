: # immediate 10 dp @ scan pop ;
# Now we can write comments like this

# Stack manipulations
: -rot rot rot ;
: over 1 pick ;
: 2pop pop pop ;
: 2dup over over ;
: nip swap pop ;
: tuck dup rot rot ;

# Abbreviations
: invert -1 xor ;
: 1+ 1 + ;
: 1- 1 - ;
: 2/ 1 asr ;
: cell+ 4 + ;
: cell- 4 - ;
: space 32 putc ;
: aligned 1- tuck + swap invert and ;
: on 1 swap ! ;
: off 0 swap ! ;
: > swap < ;
: <= > not ;
: >= < not ;
: <> = not ;

: xchg # Exchange between stack and memory
dup @ -rot ! ;

# Access to R-stack
: >r rp @ xchg rp @ cell- dup rp ! ! ;
: r> rp @ @ rp @ cell+ dup rp ! xchg ;

# Quotations
: ' word [create] ;
: ['] immediate lit lit gentok ' gentok ;
: [compile] immediate ' gentok ;
: quote immediate lit lit gentok ' gentok lit gentok gentok ;

# Control structures
: there tp @ ;

: >mark there 0 gentok ;
: >resolve there over - 2/ 1- swap tok! ;

: <mark there ;
: <resolve there - 2/ 1- gentok ;

: if immediate quote branch0 >mark ;
: else immediate quote branch >mark swap >resolve ;
: fi immediate >resolve ;

: ?dup dup if dup fi ;

: do immediate <mark 0 ;
: while immediate pop quote branch0 >mark ;
: od immediate swap quote branch <resolve ?dup if >resolve fi ;

: dump depth do ?dup while dup pick . 1- od nl ;
: clear do depth while pop od ;

# Storage allocation
: here dp @ ;
: , here dup cell+ dp ! ! ;
: constant word [create] CONST here defword , ;
: variable word [create] VAR here defword ;
: allot here + dp ! ;

# Strings
: char word ch@ ;
: [char] immediate quote lit char gentok ;
: strlen dup do dup ch@ while 1+ od swap - ;
: putstr do dup ch@ dup while putc 1+ od 2pop ;
: litstr r> dup 2 + swap tok@ over + >r ;

: " immediate
quote litstr 0 gentok [char] " there scan 
strlen 1+ 2 aligned
dup there 2 - tok! there + tp ! ;

: ." immediate [compile] " quote putstr ;


# Dictionary layout
: def>next MEM + tok@ ;
: def>exec MEM + 4 + @ ;
: def>data MEM + 8 + @ ;
: def>name MEM + 12 + ;

: names 
dict @ do dup 0 >= while dup space def>name putstr def>next od pop nl ;


# Disassembler
: isword # Test if token is in the dictionary
dict @ do dup 0 >= while 2dup = if 2pop 1 exit fi def>next od 2pop 0 ;

: disword dup isword if space def>name putstr else . fi ;

: disbody do dup tok@ dup disword ['] exit <> while 2 + od nl pop ;

: dis # Disassemble up to exit token
word find if
  dup def>exec ENTER = if
    def>data disbody
  else
    def>name putstr space ." is not a secondary" nl
  fi
else
  putstr space ." is unknown" nl
fi ;


# Top level support

: unknown # Unknown word in outer interpreter
putstr space ." is undefined" nl quit ;

: ?comp # Called from compile-only words
state @ not if ." Not compiling" nl quit fi ;

: ?interp # Called at start of :
state @ if ." Already compiling" nl 
  base @ if base @ dp ! fi quit fi ;

names
