: ' word create ;

: immediate over 4 * MEM+ @ 2 + dup tok@ 1 or swap tok! ;
' immediate 0 immediate pop pop

: # immediate 10 bp @ scan pop ;
# Now we can write comments like this

# Stack manipulations
# : rot 2 roll ;
# : over 1 pick ;
# : nip swap pop ;
# : tuck dup rot rot ;
: -rot rot rot ;
: 2pop pop pop ;
: 2dup over over ;

# Abbreviations
: invert -1 xor ;
: 1+ 1 + ;
: 1- 1 - ;
: 2/ 1 asr ;
: cell 4 ;
: cell+ 4 + ;
: cell- 4 - ;
: cells 4 * ;
: space 32 putc ;
: aligned 1- tuck + swap invert and ;
: align dp @ cell aligned dp ! ;
: on 1 swap ! ;
: off 0 swap ! ;
: > swap < ;
: <= swap < not ;
: >= < not ;
: != = not ;
: nl 10 putc ;
: inc dup @ 1+ swap ! ;
: 0< 0 < ;
: negate 0 - ;

# : xchg # Exchange between stack and memory
# dup @ -rot ! ;

# Access to R-stack
# I like these definitions, but they are probably too slow
# : >r rp @ xchg rp @ cell- dup rp ! ! ;
# : r> rp @ @ rp @ cell+ dup rp ! xchg ;

# Quotations
: ['] immediate lit lit gentok ' gentok ;
: [compile] immediate ' gentok ;
: quote immediate [compile] ['] ['] gentok gentok ;

# Storage allocation

# HERE gets the value of dp (in the ROM space if bootstrapping)
: here dp @ ;
: gentok dp @ dup 2 + dp ! tok! ;
: , dp @ dup cell+ dp ! ! ;
: constant ' align CONST here defword , ;
: variable ' align VAR here defword ;
: allot here + dp ! ;

# Control structures

# Label values are relative to defbase to allow for the earth moving
: origin defbase @ ;
: offset here origin - ;

: branch0> quote branch0 offset 0 gentok ;
: branch> quote branch offset 0 gentok ;
: >label offset over - 2/ 1- swap origin + tok! ;

: <branch quote branch offset - 2/ 1- gentok ;
: label< offset ;

: [?comp] immediate quote lit over gentok quote ?comp ;

: if immediate [?comp] branch0> ['] if ;
: else immediate ['] if ?tag branch> swap >label ['] if ;
: fi immediate ['] if ?tag >label ;

# : ?dup dup if dup fi ;

: do immediate [?comp] label< 0 ['] do ;
: while immediate ['] do ?tag pop branch0> ['] do ;
: od immediate ['] do ?tag swap <branch dup 0 >= if >label fi ;

: for immediate [?comp]
  quote swap quote >r label< quote dup quote r@ quote < 
  branch0> quote >r ['] for ;
: +repeat immediate ['] for ?tag 
  swap quote r> quote + <branch >label quote r> quote 2pop ;
: repeat immediate quote lit 1 gentok [compile] +repeat ;
: i rp @ cell+ @ ;
: j rp @ 3 cells + @ ;

: dump depth do ?dup while dup pick . 1- od nl ;
: clear do depth while pop od ;
: spaces 0 for space repeat ;
: min 2dup < if pop else nip fi ;
: max 2dup < if nip else pop fi ;
: abs dup 0< if negate fi ;

# Strings
: char word ch@ ;
: [char] immediate [?comp] quote lit char gentok ;
: strlen dup do dup ch@ while 1+ od swap - ;

: strcpy # dest source
do 2dup ch@ tuck swap ch! while 1+ swap 1+ swap od 2pop ;

# : strcmp
# do tuck ch@ dup if over ch@ swap - dup not
# else pop dup ch@ 0 fi while pop 1+ swap 1+ od nip nip ;

: putstr do dup ch@ ?dup while putc 1+ od pop ;
: litstr r> dup 2 + swap tok@ over + >r ;

: " immediate
[?comp] quote litstr 0 gentok [char] " here scan 
strlen 1+ 2 aligned dup here 2 - tok! here + dp ! ;

: ." immediate [compile] " quote putstr ;

# Reimplementation of scan
: scan # delim base
tuck do over inp @ ch@ dup 
  if tuck != fi # base delim p ch flag
while
  over ch! 1+ inp inc
od
pop 0 swap ch! pop inp @ dup ch@ if 1+ inp ! fi ;

: getdef cells MEM+ @ ;

# Dictionary layout
: tok>next   getdef tok@ ;
: tok>flags  getdef 2 + tok@ ;
: tok>action getdef 4 + @ ;
: tok>data   getdef 8 + @ ;
: tok>name   getdef 12 + ;

# Reimplementation of immed?
: immed? tok>flags 1 and 0 != ;

# Reimplementation of find
: find
  dict @
  do dup 0 >= while
    tuck tok>name over strcmp not if pop 1 exit fi 
    swap tok>next
  od
  pop 0 ;

# Reimplementation of defword
: defword		# word action data
  rot getdef tuck	# action def data def
  8 + ! tuck 4 + !      # def
  12 + putstr ."  defined" nl ;

: header # name -- token
  align

  # Allocate indirect pointer
  bp @ dup cell + bp !
  dup dp @ swap !
  MEM - 4 / swap

  # Lay out the definition
  dict @ gentok  # next
  0 gentok       # flags
  0 ,            # action
  0 ,            # data
  dup dp @ swap strcpy  # name
  strlen dp @ + 1+ 2 aligned dp !

  # Set dict
  dup dict ! ;

: moveblock # dest src nbytes -- assume 2-byte units
do dup while   
  2 - >r tuck r@ + tok@ # src dst x
  over r@ + tok! swap r>
od pop 2pop ;

# Reimplementation of create
: create
find not if 
  defbase @ not if
    header
  else
    # The Earth moves ... hold very tight please!
    ." Moving for " dup putstr nl
    dup strlen 1 + cell aligned 16 +	# (name a) where a = Size of header
    dp @ defbase @ -                    # (name a b) where b = Size of fragment 
    # Move code fragment from defbase to defbase+a
    over defbase @ tuck +               # (name a b defbase defbase+a)
    swap 2 pick moveblock               # (name a b)
    # Fake dp value and create header
    defbase @ dp !
    rot header -rot                     # (tok a b)
    # Reset defbase and restore dp
    swap defbase @ +                    # (tok b defbase+a)
    dup defbase ! + dp !                # (tok)
  fi
fi ;

: isspace 32 <= ;

# Reimplementation of word
: word
do inp @ ch@ dup if isspace fi while inp inc od
pad do inp @ ch@ dup dup if isspace not fi
while over ch! 1+ inp inc od
pop 0 swap ch! inp @ ch@ if inp inc fi pad ;


# Disassembler
: names 
dict @ do dup 0 >= while dup space tok>name putstr tok>next od pop nl ;

: isword # Test if token is in the dictionary
dict @ do dup 0 >= while 2dup = if 2pop 1 exit fi tok>next od 2pop 0 ;

: seestr dup tok@ swap 2 + tuck + swap putstr ;

: seeword # Disassemble word and advance pointer
dup tok@ 
dup ['] litstr = if 
  pop [char] " putc space 2 + seestr [char] " putc space
else
  dup ['] lit = if 
    putc 2 + dup tok@ .
  else dup ['] branch = over ['] branch0 = or if
    tok>name putstr space 2 + dup tok@ .
  else dup isword if 
    tok>name putstr space
  else 
    . 
  fi fi fi
  2 + 
fi ;

: seebody 
do dup tok@ ['] e_n_d != while seeword od nl pop ;

: see # Disassemble up to exit token
word find if
  dup tok>action ENTER = if
    tok>data seebody
  else
    tok>name putstr ."  has no mortal body" nl
  fi
else
  putstr ."  is unknown" nl
fi ;

# Top level support

: banner ." NINTH (" MEMSIZE MEM+ dp @ - . ." bytes free)" nl ;

: error ." Error: " ;

: unknown # Unknown word in outer interpreter
error putstr ."  is undefined" nl quit ;

: reset # Delete any half-complete definition
defbase @ if defbase @ dp ! fi quit ;

: ?comp # Called from compile-only words via [?comp]
state @ if pop else
  error tok>name putstr ."  is a compile-only word" nl quit 
fi ;

: ?colon # Called at start of :
state @ if error ." already in compile state -- maybe missing ;" nl reset fi ;

: ?tag # Check tags for control structure
depth 2 >= if != else 1 fi if error ." bad nesting" nl reset fi ;

names
